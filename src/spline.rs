use bevy::prelude::*;

#[derive(Component, Clone, Copy)]
pub struct Spline {
    pub controls: [SplineControl; 2],
    pub min_segment_length: f32,
}

impl Default for Spline {
    fn default() -> Self {
        Self {
            controls: Default::default(),
            min_segment_length: 10.0,
        }
    }
}

impl Spline {
    pub fn create_curve_control_points(&self) -> [[Vec3; 4]; 1] {
        let start = &self.controls[0];
        let end = &self.controls[1];

        let length = (end.pos - start.pos).length();

        [[
            start.pos,
            start.pos + start.forward * length * 0.5,
            end.pos + end.forward * length * 0.5,
            end.pos,
        ]]
    }

    /// Use points generated by create_curve_points
    pub fn create_curve_points(&self, points: [[Vec3; 4]; 1]) -> Vec<Vec3> {
        let start = points[0][0];
        let end = points[0][3];
        let segments = ((start.distance(end) / self.min_segment_length).round() as usize)
            .max(2)
            .min(10);
        CubicBezier::new(points)
            .to_curve()
            .unwrap()
            .iter_positions(segments)
            .collect()
    }
}

#[derive(Clone, Copy)]
/// Represents the start and end of a spline, also knows as knots
#[derive(Default)]
pub struct SplineControl {
    pub pos: Vec3,
    /// Points in the direction of the curve
    /// EX: for a horizontal curve the left control would point to the right
    pub forward: Vec3,
}

/// Samples a spline and generates a mesh from it
#[derive(Component)]
#[require(Spline)]
pub struct SplineMesh {}
